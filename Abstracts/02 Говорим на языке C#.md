## About
Abstract: C# 9 and .NET 5 - Modern Cross-Platform Development - Mark J. Price

Languages: rus, ukr, eng

Chapters: 2. Говорим на языке C#

# 2. Говорим на языке C#

В этой главе:
* введение в C#;
* основы языка C#;
* работа с переменными;
* работа со значениями null;
* дальнейшее изучение консольных приложений.

## Введение в C#

Данный раздел книги посвящен языку программирования C# и написан скорее для
начинающих, поэтому в нем рассматриваются основные темы, которые должны
знать все разработчики: от объявления переменных до хранения данных и определения собственных пользовательских типов данных.

Такие сложные и непонятные темы, как переназначение локальной переменной ref
и семантика ссылок с типами значений, не рассматриваются.

### Обзор версий языка и их функций 

## Версии компилятора

NET Core SDK - Roslyn --- C#
1.0.4 -------- 2.0–2.2 -- 7.0
1.1.4 -------- 2.3–2.4 -- 7.1
2.1.2 -------- 2.6–2.7 -- 7.2
2.1.200 ------ 2.8–2.10 - 7.3
3.0 ---------- 3.0–3.4 -- 8.0
5.0 ---------- 5.0 ------ 9.0

Посмотрим на имеющиеся версии .NET SDK и компилятора языка C#.
1. Запустите программу Visual Studio Code.
2. Выберите View > Terminal (Вид > Терминал)
3. Для определения имеющейся версии .NET Core SDK введите следующую команду:  
`dotnet –version`
4. Обратите внимание, что версия на момент написания — .NET Core 5.0.100, что указывает на то, что это начальная версия SDK без каких-либо исправлений ошибок или введения новых функций:  
`5.0.100`
5. Для определения имеющейся версии компилятора C# введите следующую
команду:  
`csc -langversion:?`
6. Обратите внимание на все версии, доступные на момент написания:  
`Supported language versions:`  
`default`  
`1`  
`2`  
`3`  
`4`  
`5`  
`6`  
`7.0`  
`7.1`  
`7.2`  
`7.3`  
`8.0`  
`9.0 (default)`  
`latestmajor`  
`preview`  
`latest`  

### Включение версии компилятора на определенном языке

Инструменты разработчика, такие как Visual Studio Code и интерфейс командной строки dotnet, предполагают, что вы хотите применять последнюю основную версию компилятора языка C# по умолчанию. 

Чтобы задействовать обновления доработанных версий C#, таких как 7.1, 7.2 или 7.3, вам необходимо добавить элемент конфигурации в файл проекта следующим образом:  
`<LangVersion>7.3</LangVersion>`
После выпуска C# 9.0 с .NET 5.0, если корпорация Microsoft выпустит компилятор версии C# 9.1 и вы захотите использовать его новые возможности, вам придется добавить элемент конфигурации в файл проекта следующим образом:  
`<LangVersion>9.1</LangVersion>`  
* `7`, `7.1`, `7.2`, `7.3`, `8`, `9` -- При вводе определенного номера версии данный компилятор будет использоваться, если был установлен.
* `latestmajor` -- Использует версию с наибольшим старшим номером, например 7.0 в августе 2019 года, 8.0 в октябре 2019 года, 9.0 в ноябре 2020 года.
* `latest` -- Использует версию с наибольшими старшим и младшим номерами, например 7.2 в 2017 году, 7.3 в 2018 году, 8 в 2019 году, 9 в 2020 году, возможно, 9.1 в начале 2021 года.
* `preview` -- Использует самую новую из доступных предварительных версий, например 9.0 в мае 2020 года с установленным .NET 5.0 Preview 4.

После создания проекта с помощью инструмента командной строки dotnet вы можете отредактировать файл csproj и добавить элемент `<LangVersion>` следующим образом:  
`<Project Sdk="Microsoft.NET.Sdk">`  

>`<PropertyGroup>`  

>>`<OutputType>Exe</OutputType>`  

>>`<TargetFramework>net5.0</TargetFramework>`  

>>**`<LangVersion>preview</LangVersion>`**  
 
>`</PropertyGroup>`  

`</Project>`  


Потенциальные значения для `<LangVersion>` показаны в табл. 2.12.

## Основы языка C#

Начнем с изучения основ грамматики и терминологии языка C#.

1. По завершении изучения главы 1 у вас уже должна быть папка Code в вашей пользовательской папке. В противном случае вам нужно ее создать.
2. Создайте вложенную папку Chapter02 с подпапкой Basics.
3. Запустите программу Visual Studio Code и откройте папку Chapter02/Basics.
4. В Visual Studio Code выберите `View` > `Terminal` (Вид > Терминал) и введите следующую команду:  
`dotnet new console`
5. На панели EXPLORER (Проводник) выберите файл Program.cs, а затем нажмите кнопку Yes (Да), чтобы добавить недостающие обязательные ресурсы.
6. Откройте файл Program.cs и в верхней части файла под оператором using добавьте оператор, отображающий текущую версию C# как ошибку, как показано в следующем коде:
`#error version`
7. Выберите `View` > `Problems` (Вид > Проблемы). Обратите внимание, что версия компилятора и языковая версия отображаются как номер сообщения об ошибке компилятора CS8304.
8. Закомментируйте оператор, вызывающий ошибку, как показано в следующем коде:  
`// #error version`

### Грамматика языка C#

К грамматике языка C# относятся операторы и блоки. Вы также можете оставлять пояснения к своему коду с помощью комментариев.

!!! Написание комментариев никогда не должно выступать в качестве единственного способа документирования вашего кода. Для этой цели дополнительно можно прибегнуть к выбору понятных имен для переменных и функций, написанию модульных тестов и созданию настоящих документов.

#### Операторы

Язык C# обозначает конец оператора точкой с запятой. При этом оператор может состоять из нескольких переменных и выражений. Например, для оператора totalPrice — это переменная, а subtotal + salesTax — выражение:  
`var totalPrice = subtotal + salesTax;`  
Выражение состоит из операнда subtotal, операции + и второго операнда, salesTax. Порядок операндов и операторов имеет значение.

#### Комментарии

Для описания предназначения кода вы можете добавлять комментарии, предваряя их двумя символами косой черты: //
Компилятор игнорирует любой текст после этих символов и до конца строки, например:  
`// налог с продаж должен быть добавлен к промежуточной сумме`  
`var totalPrice = subtotal + salesTax;`

Для оформления многострочного комментария используйте символы `/*` в начале
комментария и `*/` в его конце:

`/*`  
`Это многострочный`  
`комментарий.`  
`*/`

#### Блоки
В языке C# блоки кода заключаются в фигурные скобки: {}. Каждый блок начинается с объявления, описывающего то, что мы определяем. К примеру, блок может определять пространство имен, класс, метод или оператор.

`using System; // точка с запятой указывает на конец оператора`  
`namespace Basics`  
`{ // открывающая фигурная скобка указывает на начало блока`  

>`class Program`  

>`{`

>>`static void Main(string[] args)`

>>`{`  

>>>`Console.WriteLine("Hello World!"); // оператор`  

>>`}`

>`}`  

`} // закрывающая фигурная скобка указывает на конец блока`  

### Терминология языка C#

Терминологический словарь языка C# состоит из **ключевых слов**, **символов** и **типов**.

Среди предопределенных, зарезервированных ключевых слов можно выделить `using`, `namespace`, `class`, `static`, `int`, `string`, `double`, `bool`, `if`, `switch`, `break`, `while`, `do`, `for` и `foreach`.

А вот некоторые из символов: `"`, `'`, `+`, `-`, `*`, `/`, `%`, `@` и `$`

В языке C# около 100 ключевых слов.


### Изменение цветовой схемы синтаксиса
По умолчанию Visual Studio Code выделяет ключевые слова C# синим цветом, чтобы их было легче отличить от другого кода. Программа позволяет настроить цветовую схему.

1. В Visual Studio Code выберите `Code` > `Preferences` > `Color` Theme (Код > Параметры > Цветовая схема) (находится в меню File (Файл) в операционной системем Windows) или нажмите сочетание клавиш Ctrl + K, Ctrl + T.
2. Выберите цветовую схему. Для справки: я буду использовать цветовую схему Light+ (по умолчанию Light), чтобы снимки экрана выглядели четко в напечатанной книге.

### Глаголы = методы
В языке C# действия называются методами.  

В языке C# вызов или выполнение методов, таких как WriteLine, различаются в зависимости от специфики действия. Это так называемая *перегрузка*, которую мы более подробно изучим в главе 5. Рассмотрим следующий пример:

`// выводит возврат каретки`  
`Console.WriteLine();`  

`// выводит приветствие и возврат каретки`  
`Console.WriteLine("Hello Ahmed");`

`// выводит отформатированное число и дату и возврат каретки`  
`Console.WriteLine("Temperature on {0:D} is {1}°C.", DateTime.Today, 23.4);`   

Другая аналогия заключается в том, что некоторые слова пишутся одинаково, но имеют разные значения в зависимости от контекста.

### Существительные = типы данных, поля и переменные

В языке C# используются эквиваленты существительных: типы данных (чаще называемые просто типами), поля и переменные. Например, `Animal` и `Car` — типы, то есть существительные для категоризации предметов. `Head` и `Engine` — поля, то есть существительные, которые принадлежат `Animal` и `Car`. В то время как `Fido` и `Bob` — переменные, то есть существительные, относящиеся к конкретному предмету.

C# не может работать независимо. Это язык приложений, запускаемых на разных платформах .NET. На практике платформа для C# — одна
из платформ .NET. Это платформа .NET, предоставляющая десятки тысяч типов для C#. Они включают `System.Int32`, к которым относится ключевое слово-псевдоним int языка C#, и более сложные типы, такие как `System.Xml.Linq.XDocument`.

В языке C# каждый `тип` может быть отнесен к одной из категорий: `class` (класс), `struct` (структура), `enum` (перечисление), `interface` (интерфейс) или `delegate` (делегат).

#### Подсчет количества типов и методов

Мы знаем, что в языке C# существует более ста ключевых слов, но сколько типов? В нашем простом консольном приложении напишем код, позволяющий подсчитать количество типов и методов, доступных в языке C#.

1. Начнем с добавления следующих операторов в начале файла Program.cs:  
`using System.Linq;`  
`using System.Reflection;`

2. В методе Main удалите оператор, выводящий текст Hello World!, и замените его кодом, который показан ниже:  
>>`// перебор сборок, на которые ссылается приложение`  
`foreach(var r in Assembly.GetEntryAssembly().GetReferencedAssemblies())`  
`{`  
 >>>`// загрузка сборки для чтения данных`  
 `var a = Assembly.Load(new AssemblyName(r.FullName));`  
 `// объявление переменной для подсчета методов`   
 `int methodCount = 0;`  
 `// перебор всех типов в сборке`  
 `foreach (var t in a.DefinedTypes)`  
 `{`  
 `// добавление количества методов`  
 `methodCount += t.GetMethods().Count();`  
 `}`
 `// вывод количества типов и их методов`  
 `Console.WriteLine(`  
 `"{0:N0} types with {1:N0} methods in {2} assembly.",`  
 `arg0: a.DefinedTypes.Count(),`  
 `arg1: methodCount,`  
 `arg2: r.Name);`  

>>`}`

3. Выберите `View` > `Terminal` (Вид > Терминал).
4. На панели TERMINAL (Терминал) введите следующую команду:  
`dotnet run`
5. Когда эта команда будет выполнена, вы увидите следующий вывод, в котором отображается фактическое количество типов и методов, доступных вам в простейшем приложении при работе в операционной системе macOS. Количество отображаемых типов и методов может отличаться в зависимости от используемой операционной системы:

>>`// Вывод в Windows`  
`0 types with 0 methods in System.Runtime assembly.`  
`103 types with 1 094 methods in System.Linq assembly.`  
`46 types with 662 methods in System.Console assembly.`  

6. Добавьте операторы в начало метода Main, чтобы объявить некоторые переменные:
>>`static void Main(string[] args)`  
`{`
 >>>`// объявление некоторых неиспользуемых переменных с помощью типов в дополнительных сборках`  
 `System.Data.DataSet ds;`  
 `System.Net.Http.HttpClient client;`  

>>Из-за объявления переменных, использующих типы в других сборках, эти сборки загружаются с приложением, что позволяет коду видеть все типы и методы в них. Компилятор предупредит вас о наличии неиспользуемых переменных, но это не остановит выполнение вашего кода.

7. Снова запустите консольное приложение и проанализируйте результаты. Они должны выглядеть примерно так:  
>>`// Вывод в Windows`   
`0 types with 0 methods in System.Runtime assembly.`  
`376 types with 6 763 methods in System.Data.Common assembly.`  
`533 types with 5 193 methods in System.Net.Http assembly.`  
`103 types with 1 094 methods in System.Linq assembly.`  
`46 types with 662 methods in System.Console assembly.`  

        * В С# 11 количество типов поменялось незначительно.

## Работа с переменными
Любое приложение занимается обработкой данных. Они поступают, обрабатываются и выводятся. Обычно данные поступают в программы из файлов, баз данных или через пользовательский ввод. Данные могут быть на время помещены в переменные, которые хранятся в памяти работающей программы. Когда она завершается, данные стираются из памяти. Данные обычно выводятся в файлы и базы, на экран или принтер. При использовании переменных вы должны учитывать два фактора. Во-первых, как много объема памяти им требуется, и во-вторых, насколько быстро их можно обработать.

Вы можете управлять этими характеристиками, выбрав определенный тип. Простые распространенные типы, например int и double, можно представить как хранилище разного размера. Например, добавление 16-битных чисел может обрабатываться не так быстро, как добавление 64-битных чисел в 64-битной операционной системе. Некоторые хранилища можно разместить поближе для быстрого доступа, а другие — убрать подальше, в большое хранилище.

### Присвоение переменным имен

Правила именования переменных, которым рекомендуется следовать.
* Верблюжий регистр -- cost, orderDetail, dateOfBirth -- Локальные переменные и закрытые члены

* Прописной стиль -- String, Int32, Cost, DateOfBirth, Run -- Имена типов, открытые члены, такие как методы

!!! Следование набору соглашений об именах переменных позволит другим разработчикам (и вам самим в будущем!) легко понять ваш код. Дополнительную информацию о правилах присвоения имен переменным можно найти на сайте https://docs.microsoft.com/ru-ru/dotnet/standard/design-guidelines/naming-guidelines.

Блок кода, показанный ниже, отражает пример объявления и инициализации локальной переменной путем присвоения ей значения с символом =. Обратите внимание: вы можете вывести имя переменной, используя ключевое слово `nameof`, появившееся в версии C# 6.0:

`// присвоение переменной heightInMetres значения, равного 1,88`  
`double heightInMetres = 1.88;`  
`Console.WriteLine($"The variable {nameof(heightInMetres)} has the value {heightInMetres}.");`

### Литеральные значения

При присвоении значения переменной часто используются литеральные значения. Что это такое? Литералами обозначаются фиксированные значения. Типы данных используют разные обозначения для их литеральных значений.

## Хранение текста

При работе с текстом отдельная буква, например A, сохраняется как тип char и присваивается с использованием одинарных кавычек, оборачивающих литеральное значение:

`char letter = 'A'; // присваивание литеральных символов`  
`char digit = '1';`  
`char symbol = '$';`  
`char userChoice = GetKeystroke(); // присваивание из функции`

Если же используется последовательность символов, например слово Bob, то такое значение сохраняется как тип string и присваивается с использованием двойных кавычек, оборачивающих литеральное значение:  

`string firstName = "Bob"; // присваивание литеральных строк`  
`string lastName = "Smith";`  
`string phoneNumber = "(215) 555-4256";`  
`// присваивание строки, возвращаемой функцией`  
`string address = GetAddressFromDatabase(id: 563);`  

### Дословные литеральные строки
При сохранении текста в строковой переменной вы можете включить escapeпоследовательности, которые представляют собой специальные символы, такие как табуляции и новые строки. Это можно сделать с помощью обратного слеша:

`string fullNameWithTabSeparator = "Bob\tSmith";`

Подробную информацию об escape-последовательностях можно найти
на сайте https://devblogs.microsoft.com/csharpfaq/what-character-escapesequences-are-available/.

чтобы использовать дословную (verbatim) литеральную строку, необходимо использовать префикс @:

`string filePath = @"C:\televisions\sony\bravia.txt";`

Подытожим:
* литеральная строка — символы, заключенные в двойные кавычки. Они могут использовать escape-символы, такие как \t для табуляции;
* дословная литеральная строка — литеральная строка с префиксом @ для отключения управляющих символов;
* интерполированная строка — литеральная строка с префиксом $ для включения встроенных форматированных переменных. 

## Хранение чисел

Числа — данные, которые можно использовать для выполнения арифметических операций, к примеру умножения. Телефонный номер — это не число. Чтобы определиться, какое значение присваивать переменной: числовое или нет, спросите себя, нужно ли вам умножать два телефонных номера или использовать в значении специальные символы, например так: (414)-555-1234. В этих случаях число представляет собой последовательность символов, поэтому должно храниться как строка.

Числа могут быть натуральными (например, 42) и использоваться для подсчета, а также отрицательными, например –42. Это целые числа. Кроме того, числа могут быть вещественными (иначе называемые действительными), например 3,9 (с дробной частью). В программировании они представлены числами одинарной и двойной
точности с плавающей запятой.

Рассмотрим на примере чисел.
1. Создайте папку Numbers внутри папки Chapter02.
2. В программе Visual Studio Code откройте папку Numbers.
3. На панели TERMINAL (Терминал) создайте консольное приложение с помощью команды `dotnet new console`.
4. Внутри метода Main введите операторы для объявления некоторых числовых переменных, используя различные типы данных:  
`// целое число без знака означает положительное`  
`// целое число, включая 0`  
`uint naturalNumber = 23;`  
`// целое число означает отрицательное или`  
`// положительное целое число, включая 0`  
`int integerNumber = -23;`  
`// float означает число одинарной точности с плавающей запятой`  
`// суффикс F указывает, что это литерал типа float`  
`float realNumber = 2.3F;`  
`// double означает число двойной точности с плавающей запятой`  
`double anotherRealNumber = 2.3; // литерал типа double`

### Хранение целых чисел

Система десятичных чисел, также известная как Base10, имеет 10 в качестве основы, то есть десять цифр от 0 до 9. Несмотря на то что эта система чисел чаще всего используется человеком, в науке, инженерии и вычислительной технике популярны и другие системы счисления. Система двоичных чисел, также известная как Base2, имеет 2 в качестве основы, что означает наличие двух цифр: 0 и 1.

Из двух новых возможностей версии C# 7.0 и более поздних версий одна касается использования символа подчеркивания (_) в качестве разделителя групп разрядов чисел, а вторая внедряет поддержку двоичных литералов. Например, вы можете записать значение для миллиона в десятичной системе (Base10) в виде 1_000_000.

Чтобы использовать запись в двоичной системе (Base2), задействуя только 1 и 0, начните числовой литерал с `0b`.

Чтобы применить запись в шестнадцатеричной системе (Base16), используя от 0 до 9 и от A до F, начните числовой литерал с `0x`.

1. В конце метода Main введите следующий код, чтобы объявить некоторые числовые переменные, используя знак подчеркивания в качестве разделителя:  
`// три переменные, которые хранят число 2 миллиона`  
`int decimalNotation = 2_000_000;`  
`int binaryNotation = 0b_0001_1110_1000_0100_1000_0000;`  
`int hexadecimalNotation = 0x_001E_8480;`  
`// проверьте, что три переменные имеют одинаковое значение,`  
`// оба оператора выводят true`  
`Console.WriteLine($"{decimalNotation == binaryNotation}");`  
`Console.WriteLine($"{decimalNotation == hexadecimalNotation}");`
2. Запустите консольное приложение и обратите внимание, что в результате все три числа совпадают:
True
True

Компьютеры всегда могут точно представлять целые числа, используя тип int или один из его родственных типов, например long и short.

### Хранение вещественных чисел

Компьютеры не всегда могут точно представлять числа с плавающей запятой. С помощью типов float и double можно задавать вещественные числа одинарной и двойной точности с плавающей запятой.

Большинство языков программирования реализуют стандарт IEEE для арифметики с плавающей запятой. IEEE 754 — это технический стандарт для арифметики с плавающей запятой, установленный в 1985 году Институтом инженеров по электротехнике и электронике (Institute of Electrical and Electronics Engineers, IEEE)

!!! Если хотите подробно ознакомиться с числами с плавающей запятой, то можете прочитать отличный учебник на сайте https://ciechanow.ski/exposing-floating-point/.

В таблице показано, как компьютер хранит число 12.75. Обратите внимание на бит со значением 1 в столбцах 8, 4, 1/2 и 1/4.

`128|64 |32 |16 | 8 | 4 | 2 | 1 | . |1/2|1/4|1/8|1/16`  
`⠀0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | . | 1 | 1 | 0 | 0 `

Таким образом, десятичное число 12.75 в двоичной системе счисления можно изобразить как 00001100.1100. Как видите, число 12.75 может быть точно представлено в двоичной системе. Однако такое возможно не для всех чисел.

### Пример работы с числами

В языке C# есть оператор sizeof(), возвращающий количество байтов, используемых в памяти данным типом. Некоторые типы имеют члены с именами MinValue и MaxValue, возвращающие минимальные и максимальные значения, которые могут храниться в переменной этого типа. Теперь мы собираемся с помощью этих функций создать консольное приложение для изучения типов чисел.

1. В методе Main введите операторы, чтобы отобразить размер трех числовых типов данных:  
`Console.WriteLine($"int uses {sizeof(int)} bytes and can store numbers in the range {int.MinValue:N0} to {int.MaxValue:N0}.");`
`Console.WriteLine($"double uses {sizeof(double)} bytes and can store numbers in the range {double.MinValue:N0} to {double.MaxValue:N0}.");`
`Console.WriteLine($"decimal uses {sizeof(decimal)} bytes and can store numbers in the range {decimal.MinValue:N0} to {decimal.MaxValue:N0}.");`

### Сравнение типов double и decimal

1. После предыдущих операторов введите операторы для объявления двух переменных double, суммируйте их и сравните с ожидаемым результатом, а затем запишите результат в консоль:

`Console.WriteLine("Using doubles:");`  
`double a = 0.1;`  
`double b = 0.2;`  
`if (a + b == 0.3)`  
`{`  
>` Console.WriteLine($"{a} + {b} equals 0.3");`  

`}`  
`else`  
`{`  
>` Console.WriteLine($"{a} + {b} does NOT equal 0.3");`  

`}`  

2. Запустите консольное приложение и проанализируйте результат:  
`Using doubles:`  
`0.1 + 0.2 does NOT equal 0.3`

!!!Почему значение 0,1 не представлено в числах с плавающей запятой,
вы узнаете на сайте https://www.exploringbinary.com/why-0-point-1-doesnot-exist-in-floating-point/

Используйте тип `double` только если точность неважна, особенно при сравнении двух чисел; к примеру, при измерении роста человека.

Проблема в предыдущем коде заключается в том, как компьютер хранит число 0,1 или кратное 0,1. Чтобы представить 0,1 в двоичном формате, компьютер хранит 1 в столбце 1/16, 1 в столбце 1/32, 1 в столбце 1/256, 1 в столбце 1/512 и т. д. Число 0,1 в десятичной системе представлено как 0.00011001100110011… с бесконечным повторением (табл. 2.16). 

3. Скопируйте и вставьте код, который вы написали до использования переменных double.
4. Затем измените операторы, чтобы они использовали числа типа decimal, и переименуйте переменные в c и d:
`Console.WriteLine("Using decimals:");`  
`double c = 0.1M; // M обозначает литерал типа decimal`  
`double d = 0.2M;`  
`if (c + d == 0.3M)`  
`{`  
>` Console.WriteLine($"{c} + {d} equals 0.3");`  

`}`  
`else`  
`{`  
>` Console.WriteLine($"{c} + {d} does NOT equal 0.3");`  

`}`  

5. Запустите консольное приложение и проанализируйте результат вывода:  
`Using decimals:`  
`0.1 + 0.2 equals 0.3`

Тип decimal точен, поскольку хранит значение как большое целое число и смещает десятичную запятую. К примеру, 0,1 хранится как 1, с записью, что десятичная запятая смещается на один разряд влево. Число 12,75 хранится как 1275, с записью, что десятичная запятая смещается на два разряда влево.

!!! Тип `int` используйте для натуральных чисел, а `double` — для вещественных. Тип decimal применяйте для денежных расчетов, измерений в чертежах и машиностроительных схемах и повсюду, где важна точность вещественных чисел.

Типу `double` присущи некоторые полезные специальные значения. Так, `double.NaN` представляет значение, не являющееся числом, `double`. Epsilon — наименьшее положительное число, которое может быть сохранено как значение `double`, и `double.Infinity` — бесконечно большое значение. 

## Хранение логических значений

Логическое значение может содержать только одно из двух литеральных значений: или true (истина), или false (ложь):   
`bool happy = true;`  
`bool sad = false;`  
Логические значения чаще всего используются при ветвлении и зацикливании.

## Использование рабочих областей Visual Studio Code

Создадим рабочую область для двух проектов.
1. В Visual Studio Code выберите File > Save Workspace As (Файл > Сохранить рабочую область как).
2. Введите текст Chapter02 в качестве имени рабочей области, перейдите в папку
Chapter02 и нажмите кнопку Save (Сохранить).
3. Выберите команду меню File > Add Folder to Workspace (Файл > Добавить папку в рабочую область).
4. Выберите папку Basics, нажмите кнопку Add (Добавить) и обратите внимание, что теперь папки Basics и Numbers — часть рабочей области Chapter02.

!!! При использовании рабочих областей будьте осторожны при вводе команд на панели TERMINAL (Терминал). Убедитесь, что вы находитесь в правильной папке, прежде чем вводить потенциально деструктивные команды! Мы рассмотрим это в следующем задании.

## Хранение объектов любого типа 

Специальный тип object позволяет хранить данные любого типа, но такая гибкость требует жертв: код получается более сложным и менее производительным. Поэтому по возможности вы должны избегать использования типа object.

1. Создайте папку Variables и добавьте ее в рабочую область Chapter02.
2. Выберите команду меню Terminal > New Terminal (Терминал > Новый терминал).
3. Выберите проект Variables (рис. 2.5).
4. Введите команду для создания консольного приложения: `dotnet new console`.
5. Выберите View > Command Palette (Вид > Палитра команд).
6. Перейдите в каталог Chapter02 и выберите пункт `OmniSharp: Select Project`.
7. Выберите проект Variables и при появлении запроса нажмите кнопку Yes (Да), чтобы добавить необходимые ресурсы для отладки.
8. На панели EXPLORER (Проводник) в проекте Variables откройте файл Program.cs.
9. В методе Main добавьте операторы для объявления и использования некоторых переменных, задействуя тип `object`:  
`object height = 1.88; // запись double в object`  
`object name = "Amir"; // запись string в object`  
`Console.WriteLine($"{name} is {height} metres tall.");`  
`int length1 = name.Length; // выдает ошибку компиляции!`  
`int length2 = ((string)name).Length; // сообщение компилятору, что это строка`  
`Console.WriteLine($"{name} has {length2} characters.");`  
10. На панели TERMINAL (Терминал) запустите код с помощью команды `dotnet run`, и обратите внимание, что четвертый оператор не может скомпилироваться, поскольку тип данных переменной name неизвестен компилятору.
11. Закомментируйте оператор, который не может быть скомпилирован, с помощью двойной косой черты в начале оператора.
12. На панели TERMINAL (Терминал) запустите код с помощью команды `dotnet run` и обратите внимание, что компилятор может получить доступ к длине строки, если программист явно сообщает компилятору, что переменная object содержит строку:  
`Amir is 1.88 metres tall.`  
`Amir has 4 characters.`

Тип object доступен с самой первой версии языка C#, но в версии C# 2.0 и более поздних в качестве альтернативы используются более эффективные **дженерики**.

## Хранение данных динамического типа

Существует еще один специальный тип, dynamic, который тоже позволяет хранить данные любого типа и, подобно типу object, делает это за счет производительности. В отличие от типа object для значения, хранящегося в такой переменной, можно осуществлять вызов его членов без явного приведения.

1. В методе Main добавьте операторы для объявления переменной dynamic и присвойте строковое значение:  
`// хранение строки как dynamic`  
`dynamic anotherName = "Ahmed";`
2. Добавьте оператор, позволяющий получить длину значения string:  
`// компилируется, но может вызвать исключение во время`  
`// выполнения, если вы позже сохраните тип данных,`  
`// у которого нет свойства Length`  
`int length = anotherName.Length;`  

Ограничения типа dynamic заключаются в том, что программа Visual Studio Code не отображает меню IntelliSense для набора кода, поскольку компилятор не выполняет проверку во время сборки. Вместо этого общеязыковая исполняющая среда
осуществляет проверку члена во время выполнения.

## Локальные переменные

Локальные переменные объявляются внутри методов и существуют только во время вызова последних. После возвращения метода память, выделенная для хранения любых локальных переменных, освобождается.  
Строго говоря, типы значений освобождаются, а ссылочные типы должны ожидать сборку мусора. 

### Определение типа локальной переменной

1. В методе Main введите код для объявления и присвоения значений некоторым локальным переменным, используя определенные типы, как показано ниже:
`int population = 66_000_000; // 66 миллионов человек в Великобритании`  
`double weight = 1.88; // в килограммах`  
`decimal price = 4.99M; // в фунтах стерлингов`  
`string fruit = "Apples"; // строки в двойных кавычках`  
`char letter = 'Z'; // символы в одиночных кавычках`  
`bool happy = true; // логическое значение — true или false`  
Программа Visual Studio Code подчеркнет зеленой волнистой линией имена переменных, значения которым присвоены, но нигде не используются (если проект корректно открыт в VS Code).  
Вы можете использовать ключевое слово var для объявления локальных переменных. Компилятор определит тип данных по литеральному значению, введенному вами после оператора присваивания, =.  
Числовой литерал без десятичной запятой определяется как переменная `int`, если не добавлен суффикс `L`. В последнем случае определяется переменная `long`.  
Числовой литерал с десятичной запятой определяется как `double`. А если добавить суффикс `M`, то как переменная `decimal`; если `F` — то как `float`. Двойные кавычки обозначают переменную `string`, а одинарные — переменную `char`. Значения `true` и `false` определяют переменную `bool`.

2. Измените свой код так, чтобы использовать ключевое слово `var`:
`var population = 66_000_000; // 66 миллионов человек в Великобритании`  
`var weight = 1.88; // в килограммах`  
`var price = 4.99M; // в фунтах стерлингах`  
`var fruit = "Apples"; // строки в двойных кавычках`  
`var letter = 'Z'; // символы в одиночных кавычках`  
`var happy = true; // логическое значение — true или false`  
>>>Несмотря на несомненное удобство ключевого слова var, умные программисты стараются избегать его, чтобы обеспечить читабельность кода и определения типов на глаз. 

3. В начале файла класса импортируйте несколько пространств имен, как показано в следующем коде:  
`using System.IO;`  
`using System.Xml;`  

4. Для создания некоторых новых объектов под служебными словами добавьте операторы, как показано в следующем коде:  
`// удачное применение var,`  
`// поскольку он избегает повторного типа`  
`var xml1 = new XmlDocument();`  
`XmlDocument xml2 = new XmlDocument();`  
`// неудачное применение var,`  
`// поскольку мы не можем определить тип, поэтому должны использовать`  
`// конкретное объявление типа, как показано во втором выражении`  
`var file1 = File.CreateText(@"C:\something.txt");`  
`StreamWriter file2 = File.CreateText(@"C:\something.txt");`  

### Использование целевого типа выражения **new** для создания экземпляров объектов

В C# 9 Microsoft для создания экземпляров объектов представила другой синтаксис, известный как целевой тип выражения new. При создании экземпляра объекта вы можете сначала указать тип, а затем использовать new, не повторяя тип, как показано в следующем коде:  
`XmlDocument xml3 = new(); // целевой тип выражения new (версия C# 9)`

## Получение значений по умолчанию для типов

Большинство примитивных типов, кроме `string`, представляют собой типы значений. То есть им должны присваиваться значения. Вы можете определить значение по умолчанию типа, используя оператор `default()`.

Строки — ссылочные типы. Это значит, они содержат адрес значения в памяти, а не значение самой переменной. Переменная ссылочного типа может иметь значение null, которое считается литералом, указывающим, что переменная не ссылается ни на что (пока). null — значение по умолчанию для всех ссылочных типов. 

Рассмотрим значения по умолчанию.

1. В методе Main добавьте операторы для отображения значений по умолчанию int, bool, DateTime и string:  
`Console.WriteLine($"default(int) = {default(int)}");`  
`Console.WriteLine($"default(bool) = {default(bool)}");`  
`Console.WriteLine($"default(DateTime) = {default(DateTime)}");`  
`Console.WriteLine($"default(string) = {default(string)}");`  

2. Запустите консольное приложение и проанализируйте результат. Обратите внимание, что ваш вывод для даты и времени может быть отформатирован по-другому, если вы не запускаете его в Великобритании, как показано в следующем выводе:  
`default(int) = 0`  
`default(bool) = False`  
`default(DateTime) = 01/01/0001 00:00:00`  
`default(string) =`  

## Хранение нескольких значений

Если вам нужно сохранить несколько значений одного и того же типа, то можете объявить массив. В качестве примера сохраним четыре имени в строковом массиве.

Код, показанный ниже, объявляет массив для хранения четырех строковых значений. Затем в нем сохраняются строковые значения с индексами позиций от 0 до 3 (индексация массивов ведется с нуля, поэтому последний элемент всегда на единицу меньше, чем длина массива). И наконец, выполняется перебор каждого элемента в массиве с помощью оператора for.

Рассмотрим пример использования массива:
1. В папке Chapter02 создайте папку Arrays.
2. Добавьте папку Arrays в рабочую область Chapter02.
3. Создайте новое окно терминала для проекта Arrays.
4. Создайте проект консольного приложения в папке Arrays.
5. Выберите Arrays в качестве текущего проекта для OmniSharp.
6. В проекте Arrays в файле Program.cs в методе Main добавьте операторы для объявления и используйте массив строковых значений:

`// string[] names; // может ссылаться на любой массив строк`  
`// объявление размера массива`  
`string[] names = new string[4];`  
`// хранение элементов с индексами позиций`  
`names[0] = "Kate";`  
`names[1] = "Jack";`  
`names[2] = "Rebecca";`  
`names[3] = "Tom";`  
`// перебираем имена`  
`for (int i = 0; i < names.Length; i++)`  
`{`  
>` // прочитать элемент с данным индексом позиции`  
` Console.WriteLine(names[i]);`  

`}`  
7. Запустите консольное приложение и проанализируйте результат:
`Kate`  
`Jack`  
`Rebecca`  
`Tom`  
Массивы всегда имеют фиксированный размер, поэтому вам нужно предварительно решить, сколько элементов вы хотите сохранить в массиве, прежде чем создавать его.  

Массивы удобны для временного хранения нескольких элементов, а коллекции предпочтительны при динамическом добавлении и удалении элементов. 

## Работа со значениями **null**

Язык C# имеет концепцию значения null, которое может использоваться для указания того, что переменная не была установлена.

### Создание значимого типа, допускающего значение **null**

По умолчанию типы значений, такие как int и DateTime, должны всегда иметь значение, что и дало им такое название. Иногда, например при чтении значений, хранящихся в базе данных, которая допускает пустые, отсутствующие или значения null, удобно, чтобы тип значения позволял значение null. Мы называем это типом, допускающим значение null.

Вы можете включить это, добавив знак вопроса в качестве суффикса к типу при объявлении переменной. 

1. В папке Chapter02 создайте папку NullHandling.
2. Добавьте папку NullHandling в рабочую область Chapter02.
3. Создайте новое окно терминала для проекта NullHandling.
4. Создайте проект консольного приложения в папке NullHandling.
5. Выберите NullHandling в качестве текущего проекта для OmniSharp.
6. В проекте NullHandling в Program.cs в методе Main добавьте операторы для объявления и присваивания значений, включая null, переменным int:  
`int thisCannotBeNull = 4;`  
`thisCannotBeNull = null; // ошибка компиляции!`  
`int? thisCouldBeNull = null;`  
`Console.WriteLine(thisCouldBeNull);`  
`Console.WriteLine(thisCouldBeNull.GetValueOrDefault());`  
`thisCouldBeNull = 7;`  
`Console.WriteLine(thisCouldBeNull);`  
`Console.WriteLine(thisCouldBeNull.GetValueOrDefault());`  
7. Закомментируйте утверждение, которое выдает ошибку компиляции.
8. Запустите приложение и проанализируйте результат, как показано в следующем выводе:  
⠀  
`0`  
`7`  
`7`  
Первая строка пуста, поскольку выводит значение `null`!

### Ссылочные типы, допускающие значение null

В версии C# 8.0 и более поздних ссылочные типы можно настроить так, чтобы они больше не допускали значение null, установив параметр на уровне файла или проекта, включающий эту новую полезную функцию.  
Поскольку это весьма значительное изменение для языка C#, корпорация Microsoft решила сделать необходимым явное включение данной функции.

Во время перехода вы можете выбрать один из нескольких подходов для своих
проектов:
* по умолчанию — никаких изменений не требуется. Ссылочные типы, не допускающие значение null, не поддерживаются;
* включить для проекта, отключить в файлах — включить функцию на уровне проекта и отключить для всех файлов, которые должны оставаться совместимыми со старыми версиями. К данному подходу прибегает корпорация Microsoft внутри компании, когда обновляет собственные пакеты, чтобы использовать эту новую функцию;
* включать в файлах — включить функцию только для отдельных файлов.

#### Включение ссылочных типов, допускающих и не допускающих значение null

Чтобы включить эту функцию в проекте, добавьте в файл проекта следующий код:  
`<PropertyGroup>`  
`<Nullable>enable</Nullable>`  
`</PropertyGroup>`  

Чтобы отключить эту функцию в файле, добавьте следующую команду в начало кода:  
`#nullable disable`  

Чтобы включить функцию в файле, добавьте следующую команду в начало кода:  
`#nullable enable`

### Объявление переменных и параметров, не допускающих значение null

Если вы активируете ссылочные типы, допускающие значение null, и хотите, чтобы такому типу было присвоено значение null, то вам придется использовать тот же синтаксис, что и для типа значения, допускающего значение null, то есть добавить символ ? после объявления типа.

Итак, как работают ссылочные типы, допускающие значение null? Рассмотрим пример, в котором при хранении информации об адресе может потребоваться ввести значение для улицы, города и региона, но номер здания можно оставить пустым, то есть null.

1. В проекте NullHandling.csproj добавьте элемент для включения ссылочных типов, допускающих значение null, как показано выделением в следующем фрагменте кода:  
>>`<Project Sdk="Microsoft.NET.Sdk">`  
>>>>`<PropertyGroup>`  
`<OutputType>Exe</OutputType>`  
`<TargetFramework>netcoreapp5.0</TargetFramework>`  
`<Nullable>enable</Nullable>`  
  
>>>`</PropertyGroup>`  

>>`</Project>`  

2. В начале файла Program.cs добавьте оператор для включения ссылочных типов, допускающих значение null:  
`#nullable enable`  
3. В файле Program.cs в пространстве имен NullHandling над классом Program добавьте код для объявления класса Address с четырьмя полями:  
`class Address`  
`{`  
 `public string? Building;`  
` public string Street;`  
` public string City;`  
` public string Region;`  
`}`  
4. Обратите внимание: через несколько секунд расширение C# предупреждает о проблемах с полями, не допускающими значение null, такими как Street.

5. Присвойте значение пустой строки каждому из трех `полей, не допускающих значение null:`  
`public string Street = string.Empty;`  
`public string City = string.Empty;`  
`public string Region = string.Empty;`  

6. В методе Main добавьте операторы для создания экземпляра Address и установки его свойств:  
`var address = new Address();`  
`address.Building = null;`  
`address.Street = null;`  
`address.City = "London";`  
`address.Region = null;`  

7. Обратите внимание на предупреждения

Вот почему новая функция языка называется ссылочными типами, допускающими значение null. Начиная с версии C# 8.0, ссылочные типы без дополнений могут не допускать это значение, и тот же синтаксис используется для того, чтобы ссылочный тип допускал значение null, как и в случае типов значений.

### Проверка на null

Важно проверять, содержит ли значение null переменная ссылочного типа или типа, допускающего значение null. В противном случае может возникнуть исключение NullReferenceException, которое приведет к ошибке при выполнении кода.

`// проверить thisCouldBeNull на значение null перед использованием`  
`if (thisCouldBeNull != null)`  
`{`  
 `// получить доступ к thisCouldBeNull`  
 `int length = thisCouldBeNull.Length; // может возникнуть исключение`  
 `...`  
`}`  

Если вы пытаетесь получить поле или свойство из переменной, которая может быть null, используйте оператор доступа к членам с проверкой на null (?.), как показано в коде, приведенном ниже.

`string authorName = null;`  
`// выдаст исключение NullReferenceException`  
`int x = authorName.Length;`  
`// вместо вызова исключения, y получит значение null`  
`int? y = authorName?.Length;`  

!!! Более подробную информацию о null-условном операторе можно получить на сайте https://docs.microsoft.com/ru-ru/dotnet/csharp/languagereference/operators/null-conditional-operators.

Иногда требуется либо назначить переменную в качестве результата, либо использовать альтернативное значение, например 3, если переменная равна null. Это достигается с помощью оператора объединения с null (??), как показано в коде, приведенном ниже.

`// результат равен 3, если authorName?.Length равен нулю`  
`var result = authorName?.Length ?? 3;`  
`Console.WriteLine(result);`  

!!! Прочитать об операторе объединения с null можно на сайте https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/nullcoalescing-operator

## Дальнейшее изучение консольных приложений

Консольные приложения основаны на тексте и запускаются в командной строке. Обычно они выполняют простые задачи, развивающиеся по наперед заданному сценарию, такие как компиляция файла или шифрование раздела файла конфигурации. Им можно передавать аргументы для управления поведением. Примером этого может быть создание консольного приложения на языке F# с указанным именем вместо имени текущей папки, как показано в следующей командной строке:  
`dotnet new console -lang "F#" --name "ExploringConsole"`  

### Отображение вывода пользователю

Две основные задачи любого консольного приложения заключаются в записи и чтении данных. Мы уже использовали метод `WriteLine` для вывода. Если бы не требовался возврат каретки в конце каждой строки, мы могли бы применить метод `Write`.

### Форматирование с использованием пронумерованных позиционных аргументов

Использование пронумерованных позиционных аргументов — один из способов создания форматированных строк.
Эта функция поддерживается такими методами, как `Write` и `WriteLine`, а для методов, которые не поддерживают данную функцию, строковый параметр может быть отформатирован с использованием метода `Format` типа `string`.

1. Добавьте проект консольного приложения Formatting в папку и рабочую область Chapter02.

2. В методе `Main` добавьте операторы для объявления некоторых числовых переменных и записи их в консоль:  
>>`int numberOfApples = 12;`  
`decimal pricePerApple = 0.35M;`  
`Console.WriteLine(`  
 >>>`format: "{0} apples costs {1:C}",`  
 `arg0: numberOfApples,`  
 `arg1: pricePerApple * numberOfApples);`  

>>`string formatted = string.Format(`  
>>> `format: "{0} apples costs {1:C}",`  
 `arg0: numberOfApples,`  
 `arg1: pricePerApple * numberOfApples);`  

>>`//WriteToFile(formatted); // записывает строку в файл`  
Метод `WriteToFile` — несуществующий, использованный для демонстрации примера.

### Форматирование с использованием интерполированных строк
Версия C# 6.0 и выше содержит удобную функцию интерполяции строк. Она позволяет легко выводить одну или несколько переменных в удобном отформатированном виде. Строка с префиксом $ должна содержать фигурные скобки вокруг имени переменной для вывода текущего значения этой переменной в данной позиции строки.  

1. В методе Main введите оператор в конце этого метода:  
`Console.WriteLine($"{numberOfApples} apples costs {pricePerApple *
numberOfApples:C}");`  
2. Запустите консольное приложение и проанализируйте результат:  
`12 apples costs 4.20 ?` (`?` видимо означает, что компилятор не понимает, знак какой валюты использовать)  

### Форматирующие строки

Переменная или выражение могут быть отформатированы с использованием форматирующей строки после запятой или двоеточия.

Код N0 форматирует число с запятыми в качестве разделителей тысяч и без дробной части. Код C форматирует число в значение валюты. Формат последней определяет ся текущим потоком. Если вы запустите этот код на компьютере в Великобритании, то значение будет выведено в фунтах стерлингов, а если в Германии — то в евро.

Полный синтаксис форматирующего элемента выглядит следующим образом:
`{ index [, alignment ] [ : formatString ] }`

Каждый элемент форматирования можно выравнивать, что полезно при выводе таблиц значений. Некоторые значения необходимо будет выровнять по левому или правому краю в пределах ширины символов. Значения выравнивания — целые числа. При выравнивании по правому краю значения будут положительными целыми числами, а по левому краю — отрицательными целыми числами.

Например, чтобы вывести на печать таблицу фруктов и их количество, мы могли бы выровнять имена в столбце из восьми символов по левому краю и выровнять по правому краю отформатированные числа с нулевыми десятичными знаками в столбце из шести символов.

1. В методе Main введите операторы в конце этого метода:  
`string applesText = "Apples";`  
`int applesCount = 1234;`  
`string bananasText = "Bananas";`  
`int bananasCount = 56789;`  
`Console.WriteLine(`  
 `format: "{0,-8} {1,6:N0}",`  
 `arg0: "Name",`  
 `arg1: "Count");`  
`Console.WriteLine(`  
 `format: "{0,-8} {1,6:N0}",`  
 `arg0: applesText,`  
 `arg1: applesCount);`  
`Console.WriteLine(`  
 `format: "{0,-8} {1,6:N0}",`  
 `arg0: bananasText,`  
 `arg1: bananasCount);`  

2. Запустите консольное приложение и обратите внимание на эффект выравнивания и числового формата, как показано в следующем выводе:  
`Name⠀⠀⠀⠀Count`  
`Apples ⠀ 1,234`  
`Bananas 56,789`  

!!! Более подробную информацию о типах форматирования в .NET можно
прочитать на сайте https://docs.microsoft.com/ru-ru/dotnet/standard/base-types/formatting-types.

### Спецификаторы форматирования

* `C / c` Задает формат денежной единицы, указывает количество десятичных разрядов после запятой;
* `D / d` Целочисленный формат, указывает минимальное количество цифр;
* `E / e` Экспоненциальное представление числа, указывает количество десятичных разрядов после запятой;
* `F / f` Формат дробных чисел с фиксированной точкой, указывает количество десятичных разрядов после запятой;
* `G / g` Задает более короткий из двух форматов: F или E;
* `N / n` Также задает формат дробных чисел с фиксированной точкой, определяет количество разрядов после запятой;
* `P / p` Задает отображения знака процентов рядом с число, указывает количество десятичных разрядов после запятой;
* `X / x` Шестнадцатеричный формат числа.

## Получение пользовательского ввода

Мы можем получать ввод от пользователя с помощью метода `ReadLine`. Он ожидает, пока пользователь не начнет набирать некий текст. После того как тот нажал клавишу **Enter**, весь пользовательский ввод возвращается как строка.

1. В методе Main введите операторы, чтобы запросить у пользователя имя и возраст, а затем выведите пользовательскую информацию:  
`Console.Write("Type your first name and press ENTER: ");`  
`string firstName = Console.ReadLine();`  
`Console.Write("Type your age and press ENTER: ");`  
`string age = Console.ReadLine();`  
`Console.WriteLine(`  
` $"Hello {firstName}, you look good for {age}.");`  
2. Запустите консольное приложение.
3. Введите имя и возраст:  
`Type your name and press ENTER: Gary`  
`Type your age and press ENTER: 34`  
`Hello Gary, you look good for 34.`  

## Импорт пространства имен

Строка System.Console.WriteLine сообщает компилятору, что следует искать метод WriteLine в типе Console в пространстве имен System. Чтобы упростить наш код, команда dotnet new console добавляет в начало файла оператор, сообщающий компилятору, чтобы тот всегда использовал пространство имен System для типов, для которых не были указаны префиксы пространств имен, как показано в коде, приведенном ниже:
`using System;`

(В C# 11 это больше не требуется, пространство имён System подключено по умолчанию)

Так выполняется импорт пространства имен. Его результат заключается в том, что все доступные типы в этом пространстве будут доступны для вашей программы без необходимости вводить префикс пространства и будут отображаться в IntelliSense во время написания кода.

## Упрощение работы с командной строкой

В языке C# 6.0 и более поздних версиях оператор using можно использовать для дальнейшего упрощения кода. Теперь в нашем коде не нужно указывать тип Console. Вы можете найти все вхождения и удалить их с помощью функции замены в Visual Studio Code.

1. Добавьте оператор для статического импорта класса System.Console в начало файла Program.cs:  
`using static System.Console;`  
2. Выделите первое слово `Console.` в коде, убедившись, что вы также выбрали точку после слова `Console`.
3. Выберите `Edit` > `Replace` (Правка > Заменить) и обратите внимание, что отображается диалоговое окно с наложением, готовое для ввода значения, которым вы хотите заменить вариант `Console`.
4. Нажмите кнопку Replace All (Заменить все) (вторая из двух кнопок справа от поля замены) или сочетание клавиш Alt+A или Alt+Cmd+Enter для замены всех вхождений, затем закройте панель поиска щелчком кнопкой мыши на значке × в правом верхнем углу.

## Получение клавиатурного ввода от пользователя

Мы можем получить клавиатурный ввод от пользователя с помощью метода
ReadKey. Он ожидает, пока пользователь нажмет клавишу или комбинацию клавиш, которая затем возвращается как значение `ConsoleKeyInfo`.

1. В методе Main введите код, предлагающий пользователю нажать одну из клавиш (или сочетаний), а затем вывести информацию о ней:  
`Write("Press any key combination: ");`  
`ConsoleKeyInfo key = ReadKey();`  
`WriteLine();`  
`WriteLine("Key: {0}, Char: {1}, Modifiers: {2}",`  
`arg0: key.Key,`  
`arg1: key.KeyChar,`  
`arg2: key.Modifiers);`  
2. Запустите консольное приложение, нажмите клавишу K и проанализируйте результат:
`Press any key combination: k`  
`Key: K, Char: k, Modifiers: 0`  
3. Запустите консольное приложение, нажав и удерживая клавишу Shift, нажмите клавишу K и проанализируйте результат:
`Press any key combination: K`  
`Key: K, Char: K, Modifiers: Shift`  
4. Запустите консольное приложение, нажмите клавишу F12 и проанализируйте результат:  
`Press any key combination:`  
`Key: F12, Char: , Modifiers: 0`  

При запуске консольного приложения на панели TERMINAL (Терминал) программы Visual Studio Code некоторые комбинации клавиш будут захвачены редактором кода или операционной системой, прежде чем они могут быть обработаны вашим приложением.

## Чтение аргументов

Аргумент `string[] args` находится в методе `Main`. Это массив, используемый для передачи аргументов в консольное приложение. Посмотрим, как это работает.

Аргументы командной строки разделяются пробелами. Другие символы, например дефисы и двоеточия, рассматриваются как часть значения аргумента. Чтобы включить пробелы в значение аргумента, заключите значение аргумента в одинарные или двойные кавычки.

Представьте, что требуется возможность вводить имена цветов переднего плана и фона, а также размеры окна терминала в командной строке. Мы могли бы получать цвета и числа, считывая их из массива args, который всегда передается в метод `Main` консольного приложения.

1. Создайте папку Arguments для проекта консольного приложения и добавьте ее в рабочую область Chapter02.

2. Добавьте оператор для статического импорта типа System.Console и оператор для вывода количества аргументов, переданных приложению, как показано
ниже: 
>>`using System;`  
`using static System.Console;`  
`namespace Arguments`  
`{`  
>>>`class Program`  
`{`  
>>>>`static void Main(string[] args)`  
` {`  
>>>>>` WriteLine($"There are {args.Length} arguments.");`  

>>>>`}`  

>>>`}`  

>>`}`  

        Не забывайте статически импортировать тип System.Console во всех будущих проектах для упрощения кода.

3. Запустите консольное приложение и проанализируйте результат:  
`There are 0 arguments.`  

4. На панели TERMINAL (Терминал) введите несколько аргументов после команды `dotnet run`, как показано в следующей командной строке:  
`dotnet run firstarg second-arg third:arg "fourth arg"`  

5. Обратите внимание: результат указывает на четыре аргумента, как показано в следующем выводе:  
`There are 4 arguments.`  

6. Чтобы перечислить или выполнить итерации (то есть перебрать) значений этих четырех аргументов, добавьте следующие операторы осле вывода длины массива:  
`foreach (string arg in args)`  
`{`  
`WriteLine(arg);`  
`}`

7. На панели TERMINAL (Терминал) повторите те же аргументы после команды dotnet run, как показано в следующей командной строке:  
`dotnet run firstarg second-arg third:arg "fourth arg"`  

8. Обратите внимание на подробности о четырех аргументах:  
`There are 4 arguments.`  
`firstarg`  
`second-arg`  
`third:arg`  
`fourth arg`  


### Настройка параметров с помощью аргументов

Теперь мы будем применять эти аргументы, чтобы пользователь мог выбрать цвет фона, переднего плана, ширины и высоты окна вывода, а также размер курсора.

1. Добавьте операторы, запрашивающие у пользователя три аргумента, а затем проанализируйте эти аргументы и примените для настройки цвета и размера окна консоли:  
`if (args.Length < 3)`  
`{`  
 `WriteLine("You must specify two colors and cursor size, e.g.");`  
 `WriteLine("dotnet run red yellow 50");`  
 `return; // прекращение запуска`  
`}`  
`ForegroundColor = (ConsoleColor)Enum.Parse(`  
 `enumType: typeof(ConsoleColor),`  
 `value: args[0],`  
 `ignoreCase: true);`  
`BackgroundColor = (ConsoleColor)Enum.Parse(`  
 `enumType: typeof(ConsoleColor),`  
 `value: args[1],`  
 `ignoreCase: true);`  
`CursorSize = int.Parse(args[2]);`  
2. Введите на панели TERMINAL (Терминал) следующую команду:  
`dotnet run red yellow 50`

## Работа с платформами, не поддерживающими некоторые API

В операционной системе Linux это будет работать правильно. В операционной системе Windows код будет работать, но курсор не меняет свой размер. В операционной системе macOS вы увидите необработанное исключение.

Мы можем решить эту проблему с помощью обработчика исключений.

1. Измените код, чтобы обернуть строки, которые изменяют размер курсора, в оператор `try`:  
`try`  
`{`  
` CursorSize = int.Parse(args[2]);`  
`}`  
`catch (PlatformNotSupportedException)`  
`{`  
 `WriteLine("The current platform does not support changing`  
 `the size of the cursor.");`  
`}`

2. Перезапустите консольное приложение. Обратите внимание: исключение перехвачено и пользователю отображено понятное сообщение.

Еще один способ справиться с различиями в операционных системах — использовать класс операционной системы:
`if (OperatingSystem.IsWindows())`  
`{`  
 `// выполнить код, работающий только в Windows`  
`}`  

Класс `OperatingSystem` содержит эквивалентные методы для других распространенных ОС, таких как **Android**, **iOS**, **Linux**, **macOS** и даже для браузера, что полезно для веб-компонентов **Blazor**

## Практические задания

### Упражнение 2.1. Проверочные вопросы

Какой тип следует выбрать для каждого указанного ниже числа?
1. Телефонный номер. -- `string`
2. Рост. -- `ushort`, если необходимо только целое значение или `decimal` если необходимо точное дробное, или `float` если точность дробного числа не требуется. 
3. Возраст. -- `byte` будет достаочно, если речь о возрасте человека (макс значение 255). В иных случаях `ushort` или `uint` или даже `ulong` если речь о возрасте вселенной или чём-то сопоставимом.
4. Размер оклада. -- `decimal` в общем случае, но может быть упрощено до целочисленных типов.
5. Артикул книги. -- `string`
6. Цена книги. -- `decimal`
7. Вес книги. -- `float` или `double`
8. Размер населения страны. -- `uint` имеет значения до 4.2+ млрд. и не имеет отрицательных значений. 
9. Количество звезд во Вселенной. -- `double` может иметь значение "бесконечность": `double PositiveInfinity = Infinity;`
10. Количество сотрудников на каждом из предприятий малого и среднего бизнеса (примерно 50 000 сотрудников на каждом предприятии). -- `ushort` имеет значения от 0 до 65535


### Упражнение 2.2. Практическое задание — числовые размеры и диапазоны

Создайте проект консольного приложения Exercise02, которое выводит количество байтов в памяти для каждого из следующих числовых типов, а также минимальное и максимальное допустимые значения: sbyte, byte, short, ushort, int, uint, long, ulong, float, double и decimal.

Ознакомиться с документацией, касающейся составного форматирования, можно на сайте https://docs.microsoft.com/ru-ru/dotnet/standard/base-types/composite-formatting, чтобы разобраться, как выравнивать
текст в окне консольного приложения.

Результат работы вашего приложения должен выглядеть как аккуратная таблица с целыми и экспонициальными значениями.


### Упражнение 2.3. Дополнительные ресурсы

Посетите следующие сайты, чтобы получить дополнительную информацию по темам, приведенным в этой главе:
* ключевые слова C#: https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/index;

* Main() и аргументы командной строки (руководство по программированию
на C#): https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/main-andcommand-args/;
* типы (руководство по программированию на C#): https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/types/;
* операторы и выражения (руководство по программированию на C#): https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/statements-expressions-operators/;
* строки (руководство по программированию на C#): https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/strings/;
* типы значений, допускающие значения null (руководство по программированию
на C#): https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/nullable-types/;
* Ссылочные типы, допускающие значения null: https://docs.microsoft.com/ru-ru/dotnet/csharp/nullable-references;
* класс Console: https://docs.microsoft.com/ru-ru/dotnet/api/system.console.
